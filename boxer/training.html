<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>boxXcel — Training plan</title>
  <link rel="stylesheet" href="/assets/app.css" />
</head>
<body>

<script src="/auth/guard.js"></script>

<div class="shell">
  <div class="topbar" data-topbar></div>

  <div class="container">
    <div data-nav></div>

    <div class="card">
      <h2 id="dayTitle">Training plan (Age 12–15)</h2>
      <div class="small" id="dayMeta">Loading today’s plan…</div>
    </div>

    <div id="cards"></div>

    <div class="footer">
      boxXcel — Training support application. Training and information only.
    </div>
  </div>
</div>

<script src="/assets/app.js"></script>

<script>
/* ============================================================
   INIT UI
============================================================ */
renderTopbar("boxXcel — Training plan");
renderNav();

/* ============================================================
   CONFIG
============================================================ */
const SETTINGS_KEY    = "boxxcel_settings_v1";
const COMPLETIONS_KEY = "boxxcel_completions_v1"; // local fallback cache only

// ✅ IMPORTANT: your API base (note the "5l4")
const API_BASE  = "https://0v4tvwe5l4.execute-api.eu-west-2.amazonaws.com/prod";

const PROGRAMME = "12wk_fundamentals";
const AGE_GROUP = "12-15";

/* ============================================================
   AUTH / HEADERS
============================================================ */
function getIdToken() {
  // Your app seems to use id_token; fallback to access_token
  return localStorage.getItem("id_token") || localStorage.getItem("access_token") || "";
}

function authHeadersJson() {
  const t = getIdToken();
  return {
    "Content-Type": "application/json",
    "Authorization": "Bearer " + t,
  };
}

/* ============================================================
   SAFE JSON FETCH HELPERS
============================================================ */
async function apiGetJson(url) {
  const res = await fetch(url, {
    method: "GET",
    headers: authHeadersJson(),
    cache: "no-store",
  });
  const text = await res.text();
  let data = null;
  try { data = text ? JSON.parse(text) : null; } catch { data = null; }
  if (!res.ok) {
    const msg = (data && (data.error || data.message)) ? (data.error || data.message) : text;
    throw new Error(`GET failed (${res.status}): ${msg}`);
  }
  return data;
}

async function apiPostJson(url, bodyObj) {
  const res = await fetch(url, {
    method: "POST",
    headers: authHeadersJson(),
    body: JSON.stringify(bodyObj),
  });
  const text = await res.text();
  let data = null;
  try { data = text ? JSON.parse(text) : null; } catch { data = null; }
  if (!res.ok) {
    const msg = (data && (data.error || data.message)) ? (data.error || data.message) : text;
    throw new Error(`POST failed (${res.status}): ${msg}`);
  }
  return data;
}

/* ============================================================
   API URLs
============================================================ */
function cardsApiUrl() {
  return `${API_BASE}/api/cards?programme=${encodeURIComponent(PROGRAMME)}&age=${encodeURIComponent(AGE_GROUP)}`;
}

function planApiUrlForWeek(week) {
  return `${API_BASE}/api/plan?programme=${encodeURIComponent(PROGRAMME)}&age=${encodeURIComponent(AGE_GROUP)}&week=${encodeURIComponent(week)}`;
}

// ✅ NEW: server completions
function completionsApiUrl(fromISO, toISO) {
  return `${API_BASE}/api/boxer/completions?from=${encodeURIComponent(fromISO)}&to=${encodeURIComponent(toISO)}`;
}

// Existing writer endpoint
function cardCompletePostUrl() {
  return `${API_BASE}/boxer/card-complete`;
}

// ✅ boxer id resolver endpoint
function meApiUrl() {
  return `${API_BASE}/me`;
}

/* ============================================================
   UTILITIES
============================================================ */
function esc(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function todayISO(){
  const d = new Date();
  const off = d.getTimezoneOffset();
  const local = new Date(d.getTime() - off * 60000);
  return local.toISOString().slice(0,10);
}

function addDaysISO(baseISO, days){
  const d = new Date(baseISO + "T00:00:00");
  d.setDate(d.getDate() + days);
  const off = d.getTimezoneOffset();
  const local = new Date(d.getTime() - off * 60000);
  return local.toISOString().slice(0,10);
}

function loadSettings(){
  try { return JSON.parse(localStorage.getItem(SETTINGS_KEY) || "{}"); }
  catch { return {}; }
}

function saveSettings(obj){
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(obj));
}

function loadCompletionsLocal(){
  try { return JSON.parse(localStorage.getItem(COMPLETIONS_KEY) || "{}"); }
  catch { return {}; }
}

function saveCompletionsLocal(obj){
  localStorage.setItem(COMPLETIONS_KEY, JSON.stringify(obj));
}

/* ============================================================
   PROGRAMME DAY / WEEK
============================================================ */
function daysBetween(startISO, endISO){
  const s = new Date(startISO + "T00:00:00");
  const e = new Date(endISO + "T00:00:00");
  return Math.floor((e - s) / 86400000);
}

function getProgrammeDayNumber(){
  const s = loadSettings();
  if (!s.startDate) return 1;
  return Math.max(1, daysBetween(s.startDate, todayISO()) + 1);
}

function getWeekAndDay(dayNumber){
  return {
    week: Math.floor((dayNumber - 1) / 7) + 1,
    dayInWeek: ((dayNumber - 1) % 7) + 1
  };
}

/* ============================================================
   SOURCE OF TRUTH: SERVER COMPLETIONS
   - returns Map(date -> Set(card_id done=true))
============================================================ */
function buildDoneMapFromServerPayload(payload){
  // Supports either:
  // payload.by_date = { "YYYY-MM-DD": [ {card_id,is_done}, ... ] }
  // or payload.completions = [ {log_date,card_id,is_done}, ... ]
  const doneByDate = new Map();

  if (payload && payload.by_date) {
    for (const [date, arr] of Object.entries(payload.by_date)) {
      const set = new Set();
      (arr || []).forEach(x => { if (x && x.is_done) set.add(x.card_id); });
      doneByDate.set(date, set);
    }
    return doneByDate;
  }

  if (payload && Array.isArray(payload.completions)) {
    for (const row of payload.completions) {
      if (!row) continue;
      const date = row.log_date;
      if (!doneByDate.has(date)) doneByDate.set(date, new Set());
      if (row.is_done) doneByDate.get(date).add(row.card_id);
      else doneByDate.get(date).delete(row.card_id);
    }
    return doneByDate;
  }

  return doneByDate;
}

// Optional local fallback cache (only if server fails)
function getDoneSetLocalFor(date){
  const all = loadCompletionsLocal();
  const d = all[date] || { cards: [] };
  return new Set(d.cards || []);
}

function setCardCompleteLocal(date, id, done){
  const all = loadCompletionsLocal();
  const d = all[date] || { cards: [], required: [] };
  const set = new Set(d.cards || []);
  done ? set.add(id) : set.delete(id);
  all[date] = { ...d, cards: [...set] };
  saveCompletionsLocal(all);
}

function setRequiredLocal(date, ids){
  const all = loadCompletionsLocal();
  const d = all[date] || { cards: [] };
  all[date] = { ...d, required: ids };
  saveCompletionsLocal(all);
}

/* ============================================================
   BOXER ID RESOLUTION (PRODUCTION)
   - Always try settings first
   - If missing, call /me and store boxer_id
============================================================ */
async function getBoxerIdProduction(){
  const s = loadSettings();
  if (s.boxer_id) return s.boxer_id;

  // If assets/app.js defines getBoxerId() and it returns something, use it
  if (typeof getBoxerId === "function") {
    const maybe = getBoxerId();
    if (maybe) {
      s.boxer_id = maybe;
      saveSettings(s);
      return maybe;
    }
  }

  // Call /me to resolve boxer_id
  const me = await apiGetJson(meApiUrl());
  // Expecting: { ok:true, boxer_id:"...", sub:"...", email:"..." } (based on your screenshot)
  const boxer_id = me && (me.boxer_id || (me.data && me.data.boxer_id));
  if (!boxer_id) throw new Error("Could not resolve boxer_id from /me");

  s.boxer_id = boxer_id;
  saveSettings(s);
  return boxer_id;
}

/* ============================================================
   WRITE COMPLETION TO DB
============================================================ */
async function postCardCompleteToServer({ boxer_id, card_id, is_done, log_date }) {
  return apiPostJson(cardCompletePostUrl(), { boxer_id, card_id, is_done, log_date });
}

/* ============================================================
   RENDER HELPERS
============================================================ */
function list(arr){
  if (!arr || !arr.length) return `<div class="small">—</div>`;
  return `<ul class="small">${arr.map(x=>`<li>${esc(x)}</li>`).join("")}</ul>`;
}

function cardHtml(c, done){
  if (!c){
    return `
      <div class="card">
        <div class="small"><strong>Missing card</strong></div>
        <div class="small">Card referenced in plan but not returned by API.</div>
      </div>
    `;
  }

  return `
    <div class="card">
      <h2>${esc(c.title)}</h2>

      <div class="small"><strong>Goal:</strong> ${esc(c.goal)}</div>
      <div class="small"><strong>Time:</strong> ${esc(c.duration)}</div>
      <div class="small"><strong>Equipment:</strong> ${esc(c.equipment)}</div>

      <div class="small"><strong>Steps</strong></div>
      ${list(c.steps)}

      ${c.cues ? `<div class="small"><strong>Cues</strong></div>${list(c.cues)}` : ""}

      <div class="small"><strong>Safety</strong></div>
      ${list(c.safety)}

      <button class="btn ${done ? "success" : ""}" data-id="${esc(c.id)}">
        ${done ? "Completed ✓" : "Mark complete"}
      </button>
    </div>
  `;
}

/* ============================================================
   MAIN RENDER
   - Uses serverDoneMap first
   - Falls back to local if server fetch failed
============================================================ */
function renderDay(plan, cards, dayInWeek, date, doneSetForDate, useLocalCacheForRequired=false){
  const settings = loadSettings();
  const freq = settings.frequency === 6 ? 6 : 5;

  const dayPlan = plan.days.find(d => d.day === dayInWeek);
  if (!dayPlan){
    document.getElementById("dayMeta").textContent = "No plan found for today.";
    return;
  }

  document.getElementById("dayTitle").textContent =
    `Week ${plan.week} — Day ${dayPlan.day}: ${dayPlan.name}`;

  if (dayPlan.type === "rest"){
    document.getElementById("dayMeta").textContent = "Rest day";
    document.getElementById("cards").innerHTML =
      `<div class="card"><div class="small">Recovery day. No training required.</div></div>`;
    return;
  }

  const required =
    (dayPlan.type === "optional" && freq === 5) ? [] : dayPlan.card_ids;

  // keep local required for UI consistency (optional)
  if (useLocalCacheForRequired) setRequiredLocal(date, required);

  document.getElementById("dayMeta").textContent =
    required.length ? "Complete all cards to finish today" : "Optional session";

  const map = Object.fromEntries(cards.map(c => [c.id, c]));
  const done = doneSetForDate || new Set();

  document.getElementById("cards").innerHTML =
    dayPlan.card_ids.map(id => cardHtml(map[id], done.has(id))).join("");

  document.querySelectorAll("[data-id]").forEach(btn => {
    btn.onclick = async () => {
      const cardId = btn.dataset.id;
      const currentlyDone = btn.textContent.includes("Completed");
      const nextDone = !currentlyDone;

      btn.disabled = true;

      try {
        // 1) resolve boxer_id (from /me if needed)
        const boxer_id = await getBoxerIdProduction();

        // 2) write to DB
        await postCardCompleteToServer({
          boxer_id,
          card_id: cardId,
          is_done: nextDone,
          log_date: date,
        });

        // 3) update local fallback cache too (handy offline)
        setCardCompleteLocal(date, cardId, nextDone);

        // 4) reload from server so phone/laptop always consistent
        await load();

      } catch (e) {
        console.error(e);
        alert("Failed to save completion to server. Check console / CloudWatch logs.");
      } finally {
        btn.disabled = false;
      }
    };
  });
}

/* ============================================================
   LOAD
============================================================ */
async function fetchCompletionsFromServer(fromISO, toISO){
  const url = completionsApiUrl(fromISO, toISO);
  const data = await apiGetJson(url);
  if (!data || data.ok !== true) {
    throw new Error("Completions API returned unexpected response");
  }
  return data;
}

async function load(){
  const date = todayISO();
  const dayNum = getProgrammeDayNumber();
  const { week, dayInWeek } = getWeekAndDay(dayNum);

  // Fetch cards/plan in parallel
  const [cardsRes, planRes] = await Promise.all([
    fetch(cardsApiUrl(), { cache: "no-store" }),
    fetch(planApiUrlForWeek(week), { cache: "no-store" })
  ]);

  if (!cardsRes.ok || !planRes.ok){
    throw new Error("Cards/Plan API request failed");
  }

  const cards = await cardsRes.json();
  const plan  = await planRes.json();

  // ✅ Fetch completions from DB (server source of truth)
  // Pull a wide window so switching days still shows previous completions
  // (You can change this to 90 days etc.)
  const fromISO = addDaysISO(date, -120);
  const toISO   = addDaysISO(date,  1);

  let doneSetForDate = null;
  let usedLocalFallback = false;

  try {
    const payload = await fetchCompletionsFromServer(fromISO, toISO);
    const doneMap = buildDoneMapFromServerPayload(payload);
    doneSetForDate = doneMap.get(date) || new Set();
  } catch (e) {
    // Server failed -> fallback local cache (still usable, but not cross-device)
    console.warn(
      "Completions server fetch failed; using local cache fallback. Error:",
      e && e.message ? e.message : e
    );
    usedLocalFallback = true;
    doneSetForDate = getDoneSetLocalFor(date);
  }

  renderDay(plan, cards, dayInWeek, date, doneSetForDate, /*useLocalCacheForRequired=*/true);

  if (usedLocalFallback) {
    // optional: surface a subtle note
    document.getElementById("dayMeta").textContent =
      "Loaded (offline/local fallback). Server completions unavailable.";
  }
}

/* ============================================================
   BOOT
============================================================ */
load().catch(err => {
  console.error(err);
  document.getElementById("dayMeta").textContent = "Error loading training plan.";
});
</script>

</body>
</html>
